# next数组两种求法

## 一、求法的文字描述

### （1）第一种求法：根据前一个字符的next值求字符串记作 p；next 数组记作 next；

约定：

+ 下标从 1 开始算，注意，不是从 0 开始算
+ 字符串长度 >2

+ 1）第一个字母的 next 值置 0 （nesxt[1] = 0），第二个字母的 next 值置 1（next[2] = 1）
+ 2）从第 3 个开始，计算第 i 个位置的 next 值时，检查

```c
p[i-1]== p[next[i-1]] ?（即这两个值是否相等）
```

> 解释：第 i 个位置的前一个位置的值（即 p[i-1]）与以该位置的next 值（即 next[i-1]）为下标的值（即 p[next[i-1]]）是否相等

> 若相等，则 next[i] = next[i-1] + 1

> 若不等，则继续往回找，检查

```c
p[i-1]== p[next[next[i-1]]] ?
```

> 若相等，则 next[i] = next[next[i-1]] + 1

> 若不等，则继续往回找，直到找到下标为 1 还不等（即字符串第一个元素），直接赋值 next[i] = 1

### （2）第二种求法：根据最大公共元素长度求 

首先附上讲解的[博文](http://blog.csdn.net/v_july_v/article/details/7041827)地址，里面有详细讲解

+ 1）算出每一个字母前缀后缀的最大公共元素长度 
+ 2）最大公共元素长度整体向后移动一个长度，最前面的元素值填 -1，即为 next 数组的第一版本
+ 3）（如果你需要的 next 数组第一个值为 -1，这步就可以省略了）next 数组的每一个值分别+1，即求得 next 数组。

## 二、实例

现在求字符串 P = "ababaaababaa"

### (1) 对于上面的第一种解法

1) 初始化

||||||||||||||
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|P|a|b|a|b|a|a|a|b|a|b|a|a|
|下标|1|2|3|4|5|6|7|8|9|10|11|12|
|next|0|1|||||||||||

2)求下标为3的字符的next值

+ P[3-1] = P[2] = 'b';
+ next[3-1] = next[2] = 1 ;
+ P[next[3-1]] = P[1] = 'a';
+ P[3-1] != P[next[3-1]] ，但是此时已经回溯到了第一个元素
+ ∴ 直接P[3] = 1 ;

||||||||||||||
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|P|a|b|a|b|a|a|a|b|a|b|a|a|
|下标|1|2|3|4|5|6|7|8|9|10|11|12|
|next|0|1|1|||||||||||

3）求下标为 4 的字符的 next 值 

+ P[4-1] = P[3] = 'a';
+ next[4-1] = next[3] = 1 ;
+ P[next[4-1]] = P[1] = 'b';
+ P[4-1] == P[next[4-1]] ;
+ ∴ next[4] = next[4-1] + 1 = 2 ;

||||||||||||||
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|P|a|b|a|b|a|a|a|b|a|b|a|a|
|下标|1|2|3|4|5|6|7|8|9|10|11|12|
|next|0|1|1||2|||||||||

4）求下标为 5 的字符的 next 值

+ P[5-1] = P[4] = 'b'b;
+ next[5-1] = next[4] = 2 ;
+ P[next[5-1]] = P[2] = 'b';
+ P[5-1] == P[next[5-1]] ;
+ ∴ next[5] = next[5-1] + 1 = 3 ;

||||||||||||||
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|P|a|b|a|b|a|a|a|b|a|b|a|a|
|下标|1|2|3|4|5|6|7|8|9|10|11|12|
|next|0|1|1||2|3||||||||

5）求下标为 6 的字符的 next 值

+ P[6-1] = P[5] = 