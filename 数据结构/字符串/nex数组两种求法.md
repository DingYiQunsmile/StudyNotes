# next数组两种求法

## 一、概念及其实现

（１）看到网上同一个字符串求 next 数组的值有两种，一种是 -1 开头，一种是 0 开头，虽然有差别，但是以 0 开头的next数组的每一项都比以 -1 开头的next数组的对应项大1，所以，具体是以 0 开头还是以 -1 开头看需要吧，算法都是一样的．KMP 的原始论文 （K，M，P 三个家伙写的原文）中是以 0 开头的，所以下面的写法是以 0 开头的． 
（２）关于 next 数组的求法，网上能找到很多流行简洁的写法，也有很多文章对简洁代码讲解得非常细致，然而本文并不是对流行算法的剖析，而只是记录一下自己比较喜欢的计算方法，并用代码实现一下．

## 二、求法的文字描述

### （1）第一种求法：根据前一个字符的next值求字符串记作 p；next 数组记作 next；

约定：

+ 下标从 1 开始算，注意，不是从 0 开始算
+ 字符串长度 >2

+ 1）第一个字母的 next 值置 0 （nesxt[1] = 0），第二个字母的 next 值置 1（next[2] = 1）
+ 2）从第 3 个开始，计算第 i 个位置的 next 值时，检查

```c
p[i-1]== p[next[i-1]] ?（即这两个值是否相等）
```

> 解释：第 i 个位置的前一个位置的值（即 p[i-1]，记作 m）与以 m 的 next 值（即 next[i-1]）为下标的值（即 p[next[i-1]]，记作 n）是否相等

> 若相等，则 next[i] = next[i-1] + 1

> 若不等，则继续往回找，检查

```c
p[i-1]== p[next[next[i-1]]] ?
```

> 若相等，则 next[i] = next[next[i-1]] + 1

> 若不等，则继续往回找，直到找到下标为 1 还不等（即字符串第一个元素），直接赋值 next[i] = 1

### （2）第二种求法：根据最大公共元素长度求 

首先附上讲解的[博文](http://blog.csdn.net/v_july_v/article/details/7041827)地址，里面有详细讲解

+ 1）算出每一个字母前缀后缀的最大公共元素长度 
+ 2）最大公共元素长度整体向后移动一个长度，最前面的元素值填 -1，即为 next 数组的第一版本 
+ 3）（如果你需要的 next 数组第一个值为 -1，这步就可以省略了）next 数组的每一个值分别+1，即求得 next 数组。
