/**先看一个错误的对象实例化
*构造方法被私有化，无法在外部调用*/

class Singleton{
    private Singleton(){  //构造方法私有化
    }
    public void print(){
        System.out.println("Hello World.");
    }
}
public class TestDemo8 {
    public static void main(String[] args) {
        Singleton inst = null;      //声明对象
        inst = new Singleton();     //此处错误，java: Singleton()可以在Singleton中访问private
        inst.print();               //调用方法
    }
}

//现在思考？？？

//如何再保证Singleton 类中的构造方法不修改不增加,以及print()方法不修改的情况下
//如何操作才能让类的外部通过实例化对象 去调用 print()方法？？？？？


/**思考过程一:

* 现在既然构造方法被私有化，就证明，这个类的构造方法只能被本类所调用
* 所以只能再本类中产生本类的实例化对象
*/
class Singleton{
    Singleton inst = new Singleton();
    private Singleton(){  //构造方法私有化
    }
    public void print(){
        System.out.println("Hello World.");
    }
}

/**思考过程二:

* 对于一个类中的普通属性，默认情况下一定要在本类存在实例化对象滞后才可以进行调用
* 但是对于本程序来讲，无法在Singleton外部产生实例化对象,就应该想办法，
* 让Sington类中的树新风再没有Sington类实例化对象时来进行调用，此时就可以使用static来完成
* static定义的属性特点时由类名直接调用，并且可以在没有实例化对象的情况下进行调用
*/

class Singleton{
    static Singleton inst = new Singleton();
    private Singleton(){  //构造方法私有化
    }
    public void print(){
        System.out.println("Hello World.");
    }
}
public class TestDemo8 {
    public static void main(String[] args) {
        Singleton inst = Singleton.inst;
        inst.print();               //调用方法
    }
}

/**思考过程三:

* 类中的全部属性都要进行封装
* 而封装后要想取得属性，就要编写 getter方法
* 只不过这时的getter方法也应该用类名称来调用，即也定义为static型
*/

class Singleton{
    private static Singleton inst = new Singleton();
    private Singleton(){  //构造方法私有化
    }
    public void print(){
        System.out.println("Hello World.");
    }
    public static Singleton getInst(){  //取得本类对象
        return inst;
    }
}
public class TestDemo8 {
    public static void main(String[] args) {
        Singleton inst = Singleton.getInst();   //利用 "类.static方法()" 取得实例化对象
        inst.print();               //调用方法
    }
}

/**思考过程四: 这样做的目的是什么？
* 本程序中的inst属性属于static。就表示所有的Sington 类的对象不管有多少个对象声明
* 其本质都会拥有一个inst属性引用，那么既然是一个，那到底有何意义？
*/

//如果想要控制一个类中实例化对象的个数，首先要锁定的就是类中的构造方法(使用pravite 定义构造方法)
//因为实例化任何对象时，都要使用构造方法，如果构造方法被锁定，那么自然也就无法产生新的实例化对象了

/** 如果要调用类中的操作，那么就需要一个实例化对象，这是就可以在内的内部使用static方法
* 来定义一个公共的对象，并且每一次通过static方法返回唯一的一个对象
* 这样外部不管有多少次调用，最终一个类只能产生一个对象，这样的设计模式就叫做单例模式(Sington)。
*/

/** 例如计算机WindoWs上的回收站就属于单例模式
* 实际上每个硬盘上都有一个回收站，并且和桌面上的回收站是同一个
* 也就是说，在整个操作系统上只有一个回收站实例，各个地方只是引用此实例而已





